<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>PriceOp</title>
  <style type="text/css">
    body, text {
      font-family: sans-serif;
    }
    svg {
      /*border: 1px solid #08f;*/
      /*display: none;*/
    }
    .line, .line2{
      fill: transparent;
      stroke: #08f;
      stroke-width:2;
    }
    .line2{
      stroke: #f08;
    }

    .axis path,.axis line{
      fill:none;
      stroke:#000;
      stroke-width:1;
    }
  </style>
</head>
<body>
  <h1>Priceop</h1>

  <script type="text/javascript" src="bower_components/d3/d3.js"></script>
  <script type="text/javascript" src="bower_components/threejs/build/three.js"></script>
  <script type="text/javascript">
    var margin = {top: 20, right: 20, bottom: 30, left: 50},
        width = 500 - margin.left - margin.right,
        height = 500 - margin.top - margin.bottom;

    var svg = d3.select('body').append('svg')
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


    function demand1(x) {
      return Math.exp(10-0.05*x)/(1+Math.exp(10-0.05*x))
    }


    function demand2(x) {
      return Math.exp(8-0.048*x)/(1+Math.exp(8-0.048*x))
    }


    var series1 = d3.range(100,240).map(function(x){
      return {
        x:x,
        y:demand1(x)
      }
    });

    var series2 = d3.range(100,240).map(function(x){
      return {
        x:x,
        y:demand2(x)
      }
    });

    var x = d3.scale.linear()
      .range([0, width]);

    var y = d3.scale.linear()
      .range([height/2 - 20, 0]);

    var y2 = d3.scale.linear()
      .range([height, height/2 + 20]);


    var line = d3.svg.line()
      .x(function(d) { return x(d.x); })
      .y(function(d) { return y(d.y); });

    x.domain(d3.extent(series1.concat(series2), function(d) { return d.x; }));
    // y.domain(d3.extent(series1.concat(series2), function(d) { return d.y; }));
    y.domain([0,1]);

    var path1 = svg.append("path")
      .datum(series1)
      .attr("class", "line")
      .attr("d", line);

    var path2 = svg.append("path")
      .datum(series2)
      .attr("class", "line2")
      .attr("d", line);

    var xAxis = d3.svg.axis()
      .scale(x)
      .tickFormat(function(d){return '£' + d})
      .orient("bottom");

    var yAxis = d3.svg.axis()
      .scale(y)
      .tickFormat(function(d){return d*100 + '%'})
      .orient("left");


    var x_axis = svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0.5," + (height/2 + 0.5 - 20) + ")")
      .call(xAxis);

    var y_axis = svg.append("g")
      .attr("class", "y axis")
      .attr("transform", "translate(.5,.5)")
      .call(yAxis);




    function Pi1(x) {
      return demand1(x) * x;
    }


    function Pi2(x) {
      return demand2(x) * x;
    }


    var series12 = d3.range(100,240).map(function(x){
      return {
        x:x,
        y:Pi1(x)
      }
    });

    var series22 = d3.range(100,240).map(function(x){
      return {
        x:x,
        y:Pi2(x)
      }
    });


    var x2 = d3.scale.linear()
      .range([0, width]);

    var y2 = d3.scale.linear()
      .range([height, height/2 + 20]);

    x2.domain(d3.extent(series12.concat(series22), function(d) { return d.x; }));
    y2.domain(d3.extent(series12.concat(series22), function(d) { return d.y; }));
    // y2.domain([0,1]);


    var line2 = d3.svg.line()
      .x(function(d) { return x2(d.x); })
      .y(function(d) { return y2(d.y); });


    var path12 = svg.append("path")
      .datum(series12)
      .attr("class", "line")
      .attr("d", line2);

    var path22 = svg.append("path")
      .datum(series22)
      .attr("class", "line2")
      .attr("d", line2);

    var xAxis2 = d3.svg.axis()
      .scale(x)
      .tickFormat(function(d){return '£' + d})
      .orient("bottom");

    var yAxis2 = d3.svg.axis()
      .scale(y2)
      .tickFormat(function(d){return '£' + d})
      .orient("left");


    var x_axis2 = svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0.5," + (height + 0.5) + ")")
      .call(xAxis2);

    var y_axis2 = svg.append("g")
      .attr("class", "y axis")
      .attr("transform", "translate(.5,.5)")
      .call(yAxis2);







    // // part 2
    // var line2 = d3.svg.line()
    //   .x(function(d) { return x(d.x); })
    //   .y(function(d) { return y(d.y)/2; });


    // function next(){

    //   y_axis.selectAll('.tick')
    //     .transition()
    //     .attr('transform',function(d){return 'translate(0,'+y(d)/2+')'})
    //     .duration(1000)

    //   x_axis
    //     .transition()
    //     .attr("transform", "translate(0.5," + ((height/2) + 0.5) + ")")
    //     .duration(1000)

    //   path1.transition().attr('d', line2).duration(1000)
    //   path2.transition().attr('d', line2).duration(1000)

    // }


    // path1.transition().attr('d', line2).duration(3000)
    // path2.transition().attr('d', line2).duration(3000)



  </script>


  <script> 


      THREE.AxisHelper = function ( size ) {

        size = size || 1;

        var vertices = new Float32Array( [
          -.5, -.5, 0,  size-.5, -.5, 0,
          -.5, -.5, 0,  -.5, size-.5, 0,
          -.5, -.5, 0,  -.5, -.5, size
        ] );

        var colors = new Float32Array( [
          1, 0, 0,  1, 0.6, 0,
          0, 1, 0,  0.6, 1, 0,
          0, 0, 1,  0, 0.6, 1
        ] );

        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
        geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

        var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

        THREE.Line.call( this, geometry, material, THREE.LinePieces );

      };

      THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );
      THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;



      var _width = width + margin.left + margin.right;
      var _height = height + margin.top + margin.bottom;

      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera( 25, _width/_height, 0.1, 1000 );

      var renderer = new THREE.WebGLRenderer({antialiasing: true});
      renderer.setSize( _width, _height );
      document.body.appendChild( renderer.domElement );

      var geometry = new THREE.BoxGeometry( 1, 1, 1 );
      var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      var cube = new THREE.Mesh( geometry, material );
      // scene.add( cube );


      //ParametricGeometry

      function pointGenerator(x, y){

        return new THREE.Vector3( x-.5, y-.5, (Pi1((x*140)+100) + Pi2((y*140)+100))/500 );

      }


      var geometry = new THREE.ParametricGeometry( pointGenerator, 40, 40 );
      // var material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );

      var point, face, numberOfSides;

      for ( var i = 0; i < geometry.vertices.length; i++ ) 
      {
        point = geometry.vertices[ i ];
        color = new THREE.Color( 0x0000ff );
        color.setHSL( point.z*4, 1, .8  );
        geometry.colors[i] = color; // use this array for convenience
      }

      var faceIndices = [ 'a', 'b', 'c', 'd' ];
      for ( var i = 0; i < geometry.faces.length; i++ ) 
      {
        face = geometry.faces[ i ];
        numberOfSides = ( face instanceof THREE.Face3 ) ? 3 : 4;
        for( var j = 0; j < numberOfSides; j++ ) 
        {
          vertexIndex = face[ faceIndices[ j ] ];
          face.vertexColors[ j ] = geometry.colors[ vertexIndex ];
        }
      }


      var material = new THREE.MeshBasicMaterial( {vertexColors: THREE.VertexColors, side:THREE.DoubleSide })

      var surface = new THREE.Mesh( geometry, material );
      scene.add( surface );





      // draw a line
      var material = new THREE.LineBasicMaterial({
          color: 0x0000ff,
          linewidth: 3
      });

      var geometry = new THREE.Geometry();

      d3.range(0,100).forEach(function(i){

        geometry.vertices.push(
          pointGenerator(i/100, i/100)
        );

        // geometry.vertices.push(new THREE.Vector3(-1, 0, 0));

      })

      var line = new THREE.Line(geometry, material);

      scene.add(line);



      var axisHelper = new THREE.AxisHelper( 1 );
      scene.add( axisHelper );


      camera.position.z = 4;
      camera.lookAt(new THREE.Vector3(-.5,.5,0))


      surface.rotation.x = 30;
      surface.position.x = -.5;


      line.rotation.x = 30;
      line.position.x = -.5;


      axisHelper.rotation.x = 30;
      axisHelper.position.x = -.5;
      // axisHelper.position.z = -.5;


      var render = function () {
        requestAnimationFrame( render );

        // cube.rotation.x += 0.01;
        // cube.rotation.y += 0.01;

        
        // surface.rotation.x += 0.01;
        // surface.rotation.y += 0.01;

        surface.rotation.z += 0.01;
        line.rotation.z += 0.01;

        axisHelper.rotation.z += 0.01;

        renderer.render(scene, camera);
      };

      render();
    </script>

</body>
</html>